<!-- @cmp-manifest
{
  "schema": "cmp-manifest/v1",
  "id": "math.geometry.compass.interactive",
  "name": "圆规（交互式）",
  "nameEn": "Compass (Interactive)",
  "category": "math/geometry",
  "version": "1.2.0",
  "viewport": { "w": 300, "h": 300 },
  "props": [
    { "key": "size", "type": "number(px)", "default": 300, "min": 150, "max": 600, "desc": "组件尺寸" },
    { "key": "metalColor", "type": "color", "default": "#888888", "desc": "金属部件颜色" },
    { "key": "pencilColor", "type": "color", "default": "#ffb74d", "desc": "铅笔腿颜色" },
    { "key": "arcColor", "type": "color", "default": "#1565c0", "desc": "圆弧颜色" },
    { "key": "stroke", "type": "color", "default": "#555555", "desc": "描边颜色" },
    { "key": "strokeWidth", "type": "number", "default": 1.5, "min": 0.5, "max": 4, "desc": "描边宽度" },
    { "key": "accent", "type": "color", "default": "#d32f2f", "desc": "半径文字颜色" },
    { "key": "glow", "type": "number(0-1)", "default": 0, "min": 0, "max": 1, "desc": "发光强度" }
  ],
  "cssVars": {
    "size": "--cmp-size",
    "metalColor": "--cmp-metal-color",
    "pencilColor": "--cmp-pencil-color",
    "arcColor": "--cmp-arc-color",
    "stroke": "--cmp-stroke",
    "strokeWidth": "--cmp-stroke-width",
    "accent": "--cmp-accent",
    "glow": "--cmp-glow"
  },
  "tags": ["compass", "geometry", "circle", "radius", "interactive", "math", "drawing"],
  "events": [
    { "name": "cmp:change", "type": "drag", "values": { "radius": "number", "sweepDeg": "number — 已画弧度数" } },
    { "name": "cmp:changeend", "type": "drag", "values": { "radius": "number", "sweepDeg": "number" } }
  ]
}
-->
<div class="cmp" data-cmp-id="math.geometry.compass.interactive" role="img" aria-label="圆规（交互式）">
  <style>
    .cmp[data-cmp-id="math.geometry.compass.interactive"] {
      --size: var(--cmp-size, 300px);
      display: inline-block;
      width: var(--size);
      height: var(--size);
      user-select: none;
      touch-action: none;
      filter: drop-shadow(0 0 calc(12px * var(--cmp-glow, 0)) rgba(21,101,194, calc(0.5 * var(--cmp-glow, 0))));
    }
    .cmp[data-cmp-id="math.geometry.compass.interactive"] svg {
      display: block; width: 100%; height: 100%; overflow: visible;
    }
    .cmp[data-cmp-id="math.geometry.compass.interactive"] .cp__pivot-handle {
      cursor: grab;
    }
    .cmp[data-cmp-id="math.geometry.compass.interactive"] .cp__pivot-handle:active {
      cursor: grabbing;
    }
    .cmp[data-cmp-id="math.geometry.compass.interactive"] .cp__pencil-handle {
      cursor: pointer;
    }
    .cmp[data-cmp-id="math.geometry.compass.interactive"] .cp__info {
      font-family: Arial, sans-serif;
      font-size: 10px;
      font-weight: bold;
      pointer-events: none;
    }
  </style>

  <svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <!-- 画出的弧线轨迹 -->
    <path class="cp__trail" d="" fill="none" stroke-width="1.8" stroke-linecap="round" opacity="0"/>

    <!-- 针腿 -->
    <line class="cp__needle-leg" stroke-width="3" stroke-linecap="round"/>
    <!-- 铅笔腿 -->
    <line class="cp__pencil-leg" stroke-width="3" stroke-linecap="round"/>
    <!-- 针尖 -->
    <circle class="cp__needle-tip" r="2.5"/>
    <!-- 铅笔尖三角 -->
    <polygon class="cp__pencil-tri"/>
    <!-- 铅笔芯 -->
    <line class="cp__pencil-core" stroke-width="1.5" stroke-linecap="round" stroke="#333"/>
    <!-- 铰接点 -->
    <circle class="cp__pivot" r="5"/>
    <circle class="cp__pivot-inner" r="2.5" fill="#ccc" stroke="none"/>

    <!-- 拖拽手柄 -->
    <circle class="cp__pivot-handle" r="14" fill="transparent" stroke="none"/>
    <circle class="cp__pencil-handle" r="12" fill="transparent" stroke="none"/>

    <!-- 信息文字 -->
    <text class="cp__info" x="150" y="295" text-anchor="middle"></text>
  </svg>
</div>

<script>
(function() {
  var script = document.currentScript;
  if (!script) return;
  var root = script.previousElementSibling;
  if (!root || root.getAttribute('data-cmp-id') !== 'math.geometry.compass.interactive') return;

  var svg = root.querySelector('svg');
  if (!svg) return;

  var trail    = svg.querySelector('.cp__trail');
  var nLeg     = svg.querySelector('.cp__needle-leg');
  var pLeg     = svg.querySelector('.cp__pencil-leg');
  var nTip     = svg.querySelector('.cp__needle-tip');
  var pTri     = svg.querySelector('.cp__pencil-tri');
  var pCore    = svg.querySelector('.cp__pencil-core');
  var pivotC   = svg.querySelector('.cp__pivot');
  var pivotIn  = svg.querySelector('.cp__pivot-inner');
  var pivotH   = svg.querySelector('.cp__pivot-handle');
  var pencilH  = svg.querySelector('.cp__pencil-handle');
  var infoTxt  = svg.querySelector('.cp__info');

  /*
   * 几何模型（简洁版）：
   *   - 针尖固定在 (NX, NY)，这是圆心
   *   - halfAngle 控制两腿张开的半角（度），决定半径
   *   - rotation 控制整个圆规绕针尖的朝向（弧度）
   *   - 铰接点在针尖正上方，两腿对称向下张开
   *   - 整体再绕针尖旋转 rotation 角度
   */
  var NX = 150, NY = 190;
  var LEG = 120;
  var halfAngle = 18;          /* 半角（度），初始 ~18° */
  var rotation = 0;            /* 整体旋转（弧度），0 = 铰接点正上方 */

  /* 画弧状态 */
  var drawing = false;
  var adjusting = false;
  var drawStartRot = 0;
  var accumSweep = 0;
  var prevMouseAngle = 0;

  function deg2rad(d) { return d * Math.PI / 180; }

  /* 计算铰接点和两个尖端的绝对坐标 */
  function geometry() {
    var ha = deg2rad(halfAngle);
    /* 未旋转时：铰接点在 (0, -LEG*cos(ha))，针尖在 (-LEG*sin(ha), 0)，铅笔尖在 (+LEG*sin(ha), 0) */
    /* 但我们以针尖为原点，所以先算相对针尖的坐标 */
    /* 铰接点相对针尖：(LEG*sin(ha), -LEG*cos(ha)) — 即针尖在左下，铰接点在右上 */
    /* 不对，重新想：铰接点在上方，两腿对称向下 */
    /* 以铰接点为局部原点：针尖 = (-sin(ha)*LEG, cos(ha)*LEG)，铅笔尖 = (+sin(ha)*LEG, cos(ha)*LEG) */
    /* 以针尖为原点：铰接点 = (sin(ha)*LEG, -cos(ha)*LEG)，铅笔尖 = (2*sin(ha)*LEG, 0) */
    var sinA = Math.sin(ha), cosA = Math.cos(ha);
    /* 相对针尖（未旋转） */
    var pivRx = sinA * LEG;
    var pivRy = -cosA * LEG;
    var penRx = 2 * sinA * LEG;
    var penRy = 0;

    /* 绕针尖旋转 rotation */
    var cr = Math.cos(rotation), sr = Math.sin(rotation);
    return {
      pivX: NX + pivRx * cr - pivRy * sr,
      pivY: NY + pivRx * sr + pivRy * cr,
      penX: NX + penRx * cr - penRy * sr,
      penY: NY + penRx * sr + penRy * cr,
      radius: 2 * sinA * LEG
    };
  }

  function colors() {
    var cs = getComputedStyle(root);
    return {
      metal:  cs.getPropertyValue('--cmp-metal-color').trim()  || '#888888',
      pencil: cs.getPropertyValue('--cmp-pencil-color').trim() || '#ffb74d',
      arc:    cs.getPropertyValue('--cmp-arc-color').trim()    || '#1565c0',
      stroke: cs.getPropertyValue('--cmp-stroke').trim()       || '#555555',
      sw:     parseFloat(cs.getPropertyValue('--cmp-stroke-width')) || 1.5,
      accent: cs.getPropertyValue('--cmp-accent').trim()       || '#d32f2f'
    };
  }

  function render() {
    var c = colors();
    var g = geometry();

    /* 针腿 */
    nLeg.setAttribute('x1', g.pivX); nLeg.setAttribute('y1', g.pivY);
    nLeg.setAttribute('x2', NX);     nLeg.setAttribute('y2', NY);
    nLeg.setAttribute('stroke', c.metal);

    /* 铅笔腿 */
    pLeg.setAttribute('x1', g.pivX); pLeg.setAttribute('y1', g.pivY);
    pLeg.setAttribute('x2', g.penX); pLeg.setAttribute('y2', g.penY);
    pLeg.setAttribute('stroke', c.pencil);

    /* 针尖 */
    nTip.setAttribute('cx', NX); nTip.setAttribute('cy', NY);
    nTip.setAttribute('fill', c.stroke);

    /* 铅笔尖三角 */
    var tipLen = 8, tipHalf = 3;
    var pdx = g.penX - g.pivX, pdy = g.penY - g.pivY;
    var pdl = Math.sqrt(pdx * pdx + pdy * pdy) || 1;
    pdx /= pdl; pdy /= pdl;
    var ppx = -pdy, ppy = pdx;
    var tb = { x: g.penX + pdx * tipLen, y: g.penY + pdy * tipLen };
    var tl = { x: g.penX - ppx * tipHalf, y: g.penY - ppy * tipHalf };
    var tr = { x: g.penX + ppx * tipHalf, y: g.penY + ppy * tipHalf };
    pTri.setAttribute('points', tl.x+','+tl.y+' '+tb.x+','+tb.y+' '+tr.x+','+tr.y);
    pTri.setAttribute('fill', c.pencil);
    pTri.setAttribute('stroke', c.stroke);
    pTri.setAttribute('stroke-width', c.sw * 0.5);

    /* 铅笔芯 */
    var cm = { x: g.penX + pdx * tipLen * 0.5, y: g.penY + pdy * tipLen * 0.5 };
    pCore.setAttribute('x1', cm.x); pCore.setAttribute('y1', cm.y);
    pCore.setAttribute('x2', tb.x); pCore.setAttribute('y2', tb.y);

    /* 铰接点 */
    pivotC.setAttribute('cx', g.pivX); pivotC.setAttribute('cy', g.pivY);
    pivotC.setAttribute('fill', c.metal);
    pivotC.setAttribute('stroke', c.stroke);
    pivotC.setAttribute('stroke-width', c.sw);
    pivotIn.setAttribute('cx', g.pivX); pivotIn.setAttribute('cy', g.pivY);

    /* 手柄 */
    pivotH.setAttribute('cx', g.pivX); pivotH.setAttribute('cy', g.pivY);
    pencilH.setAttribute('cx', g.penX); pencilH.setAttribute('cy', g.penY);

    /* 信息 */
    var sweepDeg = Math.abs(accumSweep) * 180 / Math.PI;
    infoTxt.setAttribute('fill', c.accent);
    if (sweepDeg > 0.5) {
      infoTxt.textContent = 'r=' + Math.round(g.radius) + '  ' + Math.round(sweepDeg) + '\u00B0';
    } else {
      infoTxt.textContent = 'r=' + Math.round(g.radius);
    }

    trail.setAttribute('stroke', c.arc);
  }

  /* ── 画弧 ── */
  function updateTrail() {
    if (!drawing) return;
    if (Math.abs(accumSweep) < 0.005) {
      trail.setAttribute('opacity', '0');
      return;
    }

    var g = geometry();
    var r = g.radius;
    var startA = drawStartRot;
    var total = accumSweep;
    var dir = total > 0 ? 1 : -1;
    var absT = Math.abs(total);
    var sweepFlag = dir > 0 ? 1 : 0;
    /* 拆成 <= PI 的段 */
    var segs = Math.ceil(absT / (Math.PI * 0.99));
    var segA = total / segs;

    var curA = startA;
    var d = '';
    for (var i = 0; i < segs; i++) {
      var nextA = curA + segA;
      /* 铅笔尖在 rotation=curA 时的位置 */
      var sx = NX + r * Math.cos(curA);
      var sy = NY + r * Math.sin(curA);
      var ex = NX + r * Math.cos(nextA);
      var ey = NY + r * Math.sin(nextA);
      var large = Math.abs(segA) > Math.PI ? 1 : 0;
      if (i === 0) d += 'M' + sx.toFixed(2) + ',' + sy.toFixed(2);
      d += ' A' + r.toFixed(2) + ',' + r.toFixed(2)
         + ' 0 ' + large + ',' + sweepFlag
         + ' ' + ex.toFixed(2) + ',' + ey.toFixed(2);
      curA = nextA;
    }

    trail.setAttribute('d', d);
    trail.setAttribute('opacity', '0.8');
  }

  /* ── 事件 ── */
  function emitCmp(name) {
    var g = geometry();
    var sweepDeg = Math.abs(accumSweep) * 180 / Math.PI;
    root.dispatchEvent(new CustomEvent(name, {
      bubbles: true, composed: true,
      detail: {
        id: root.getAttribute('data-cmp-id'),
        type: 'drag',
        values: { radius: Math.round(g.radius), sweepDeg: Math.round(sweepDeg * 10) / 10 }
      }
    }));
  }

  function svgPt(cx, cy) {
    var pt = svg.createSVGPoint();
    pt.x = cx; pt.y = cy;
    var ctm = svg.getScreenCTM();
    if (!ctm) return null;
    return pt.matrixTransform(ctm.inverse());
  }

  /* ── 拖铰接点（顶部）→ 画弧 ── */
  pivotH.addEventListener('pointerdown', function(e) {
    e.preventDefault(); e.stopPropagation();
    drawing = true;
    /* 铅笔尖当前角度 = rotation（相对针尖的角度） */
    drawStartRot = rotation;
    accumSweep = 0;
    /* 记录鼠标相对针尖的初始角度 */
    var p = svgPt(e.clientX, e.clientY);
    if (p) {
      prevMouseAngle = Math.atan2(p.y - NY, p.x - NX);
    } else {
      prevMouseAngle = 0;
    }
    trail.setAttribute('d', '');
    trail.setAttribute('opacity', '0');
    svg.setPointerCapture(e.pointerId);
  });

  /* ── 拖铅笔尖（底部）→ 调半径 ── */
  pencilH.addEventListener('pointerdown', function(e) {
    e.preventDefault(); e.stopPropagation();
    adjusting = true;
    svg.setPointerCapture(e.pointerId);
  });

  svg.addEventListener('pointermove', function(e) {
    if (!adjusting && !drawing) return;
    e.preventDefault();
    var p = svgPt(e.clientX, e.clientY);
    if (!p) return;

    if (adjusting) {
      /* 铅笔尖到针尖的距离 → 半径 → 反算 halfAngle */
      var dx = p.x - NX, dy = p.y - NY;
      var dist = Math.sqrt(dx * dx + dy * dy);
      /* radius = 2 * sin(halfAngle) * LEG，所以 sin(ha) = dist / (2*LEG) */
      var sinHa = Math.max(0.05, Math.min(0.95, dist / (2 * LEG)));
      halfAngle = Math.asin(sinHa) * 180 / Math.PI;
      /* 更新朝向 */
      rotation = Math.atan2(dy, dx);
      render();
      emitCmp('cmp:change');
    }

    if (drawing) {
      /* 鼠标绕针尖的角度变化 → 圆规同步旋转 */
      var dx2 = p.x - NX, dy2 = p.y - NY;
      var mouseAngle = Math.atan2(dy2, dx2);
      var delta = mouseAngle - prevMouseAngle;
      /* 归一化 delta */
      while (delta > Math.PI) delta -= 2 * Math.PI;
      while (delta < -Math.PI) delta += 2 * Math.PI;
      accumSweep += delta;
      prevMouseAngle = mouseAngle;
      rotation += delta;
      render();
      updateTrail();
      emitCmp('cmp:change');
    }
  });

  svg.addEventListener('pointerup', function(e) {
    if (adjusting) {
      adjusting = false;
      try { svg.releasePointerCapture(e.pointerId); } catch(ex) {}
      emitCmp('cmp:changeend');
    }
    if (drawing) {
      drawing = false;
      try { svg.releasePointerCapture(e.pointerId); } catch(ex) {}
      emitCmp('cmp:changeend');
    }
  });

  svg.addEventListener('pointercancel', function() {
    adjusting = false;
    drawing = false;
  });

  /* 初始渲染 */
  render();
})();
</script>
